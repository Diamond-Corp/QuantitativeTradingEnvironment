//
//  OrderManager.h
//  QuantitativeTradingEnvironment
//
//  Created by Shashank Choudhary on 2/6/23.
//

#ifndef OrderManager_h
#define OrderManager_h

#include "AppBase.h"

//This class will manage all orders sent to the venues, based on signals generated by your strategy. It will handle sending, canceling and replacing orders as well as accessing information about executed orders, including pending and open orders.

class OrderManager : public AppBase
{
public:
    unsigned order_id;
    Order order;
    ExecutionOrder execution_order;
    unordered_map<unsigned int, ExecutionOrder> list_orders;
    unordered_map<string, int> positions;
    OrderManager(std::queue<Order> &strategy_to_ordermanager_,
                 std::queue<ExecutionOrder> &ordermanager_to_strategy_,
                 std::queue<Order> &ordermanager_to_simulator_,
                 std::queue<ExecutionOrder> &simulator_to_ordermanager_, std::queue<BookUpdate>&bookbuuilder_to_strategy_):AppBase(strategy_to_ordermanager_,
                ordermanager_to_strategy_,
                ordermanager_to_simulator_,
                simulator_to_ordermanager_,bookbuuilder_to_strategy_)
                ,order_id(0){};
    virtual void start() { is_working = true;}
    virtual void stop() {
        is_working = false;
        list_orders.clear();
    }
    void reset_position(){ positions.clear();}
    bool handle_order();
    bool handle_execution_order();
    unsigned int get_number_of_non_acknowledged_orders();
    unsigned int get_number_of_open_orders();
    int get_position(std::string symbol);
    
};

bool OrderManager::handle_order()
{
    if(!is_working) return false;
    if(strategy_to_ordermanager.empty()) return true;
    const Order&e = strategy_to_ordermanager.front();
    strategy_to_ordermanager.pop();
    
    //order_id = e.getId();
    ++order_id;
    order.setType(e.getOrderType());
    order.setVenue(e.getVenue());
    order.setSymbol(e.getSymbol());
    order.setPrice(e.getPrice());
    order.setQuantity(e.getQuantity());
    order.setOrderId(order_id);
    order.setSide(e.isBuy());
    
    execution_order.setType(e.getOrderType());
    execution_order.setVenue(e.getVenue());
    execution_order.setSymbol(e.getSymbol());
    execution_order.setPrice(e.getPrice());
    execution_order.setQuantity(e.getQuantity());
    execution_order.setOrderId(order_id);
    execution_order.setSide(e.isBuy());
    execution_order.setState(orderstate::OPEN);
    
    int position = (order.isBuy() ? 1: -1) * order.getPrice() * order.getQuantity();
    if(abs(position) >= 1e6)
    {
        execution_order.setState(orderstate::REJECTED);
        ordermanager_to_strategy.push(execution_order);
        return true;
    }
    
    if(get_number_of_non_acknowledged_orders() == 11)
    {
        execution_order.setState(orderstate::REJECTED);
        ordermanager_to_strategy.push(execution_order);
        return true;
        
    }
    
    
    list_orders[order_id] = execution_order;
    ordermanager_to_simulator.push(order);
    return true;
    
    
    
}

bool OrderManager::handle_execution_order()
{
    if(!is_working) return false;
    if(simulator_to_ordermanager.empty()) return true;
    
    const ExecutionOrder &e = simulator_to_ordermanager.front();
    simulator_to_ordermanager.pop();
    
    list_orders[e.getId()].setState(e.getState());
    int position = (order.isBuy() ? 1 : -1) * order.getPrice() * order.getQuantity();
    if(e.getState() == orderstate::FILLED)
    {
        if(positions.find(order.getSymbol()) != positions.end())
            positions[order.getSymbol()] += position;
        else
            positions[order.getSymbol()] = position;
    }
    
    ordermanager_to_strategy.push(e);
    return true;
    
}

unsigned int OrderManager::get_number_of_open_orders()
{
    unsigned int number_of_open_orders = 0;
    for(auto itr : list_orders)
    {
        if(itr.second.getState() == orderstate::OPEN || itr.second.getState() == orderstate::ACKNOWLEDGED)
            number_of_open_orders++;
    }
    return number_of_open_orders;
}

unsigned int OrderManager::get_number_of_non_acknowledged_orders()
{
    unsigned int number_of_nonack_orders = 0;
    for(auto itr : list_orders)
    {
        if(itr.second.getState() == orderstate::OPEN)
            number_of_nonack_orders++;
    }
    return number_of_nonack_orders;
    
}

int OrderManager::get_position(std::string symbol)
{
    if(positions.find(symbol) != positions.end())
        return positions[symbol];
    else
        return 0;
}




#endif /* OrderManager_h */
